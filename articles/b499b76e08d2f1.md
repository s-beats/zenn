---
title: "【Go】Go歴1年になったのでfmt.Println()を覗いてみた"
emoji: "🍍"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go"]
published: false
---

Goを書き始めて早1年の月日が経ちました。

初めて`fmt.Println("Hello World")`と書いた日のことを懐かしく思います。
`Hello World`とプリントすることはもうほとんどないのですが、`fmt.Println`にはお世話になりっぱなしです。
せっかくなのでこの機会に `fmt.Println` の実装をゆるく覗いていきたいと思います。

```go
fmt.Println("Hello World")
```

引数の型は任意の数の interface{} 、戻り値の型は int と error となっています。
ちゃんと戻り値ありますね。今のところ戻り値を変数に代入したことは一度もないですが。

関数の内容は1行のみで、`fmt.Fprintln` を呼び出しています。
ということは`fmt.Println`を読むことは`fmt.Fprintln`を読むようなものですね。

`fmt.Fprintln` の第一引数には `os.Stdout` を渡していますので、`fmt.Println`による書き出しは `os.Stdout` に代入されている `*os.File` 型の値が持つ、 `Write` メソッドによって行われることがわかります。

`Fprintln` を見ていきましょう。
`*pp` というプリンタの状態を管理する構造体を初期化し、メソッドを呼んだりバッファを書き出したりしています。
`Write` の戻り値をreturnしていますので、`fmt.Println`、`fmt.Fprintln`の戻り値は`Write`の戻り値であるということが分かります。
正直ここまででもう満足な気もしますが、もうちょっと深堀ってみようと思います。

初期化関数の `newPrinter` を見ていきましょう。
`ppFree.Get().(*pp)`で`*pp`型の値を作り、作った値のフィールドに初期値を突っ込んでいます。
フィールドへの代入はさておき、`ppFree.Get().(*pp)`が気になりますね。
見慣れない関数を呼んでその戻り値のinterface{}を`*pp`型に型アサーションしています。
この見慣れない関数は一体何者でしょうか。

見慣れない関数は、`sync.Pool`構造体のメソッドです。
フィールドの`New`に初期化した`*pp`を返す関数を入れているので、おそらく`sync.Pool`構造体の`Get`メソッドの中でこの`New`が呼ばれているのでしょう。
`sync.Pool`とはなんぞや。

がっつりコメントがあるので頑張って読んでみましたがイマイチわかりません。
積読していたオライリー本を読んだり、技術記事を漁ったりしてみましたがふんわりしています。
とりあえず現状で分かったこととしては、

- オブジェクト(interface{}なので構造体だったり、スライスだったり諸々)を効率的に扱うためのプール
- `Get`でプールからオブジェクトを取得
    - プールに待機中のオブジェクトがあればそれを返し、なければ`New`したものを返す
- `Put`でプールにオブジェクトを返却
- `Get`と`Put`はゴルーチン安全

`pp`構造体使いまわせますよ、確保した`[]byte`再利用しようぜってことですかね？
`sync.Pool`のことはもう少しちゃんと調べないといけませんが、雰囲気理解ということで読み進めます。

プールからリソースを取得する`Get`の中で`New`が呼ばれていることが分かりました。
ちなみにプールに返却する`Put`はというと、`pp`構造体のメソッド`free`内で呼ばれていました。

それでは最後に`doPrintln`を見ていきます。
こちらでは`pp`構造体のメソッド`printArg`を呼び出し、`Println`の引数として渡された任意の値を、順番にバッファに書き込んでいっています。
フォーマット指定子は常に`%v`が指定されています。
また、`doprint**ln**`ですので最終の引数の後には`\n`が書き込まれます。

`Fprintln`の中で行われている処理をざっとまとめると、

プールから`pp`構造体を取得
↓
出力したい値をバッファに書き込み
↓
バッファに書き込んだ値を出力先に書き込み
↓
プールに`pp`構造体を返却

といった流れとなります。

まとめ

今回はGoを書き始めて約1年の節目ということで、`fmt.Println`を覗いてみました。
特に何かを解決しようという目的もなく、標準パッケージのソースコードを読んだのは初めてでしたが楽しかったです。（普段読む時は大体実装うまくいかなくて切羽詰まった状態）
また、`sync.Pool`を知ることができたことが1番の収穫でした。
スキルアップと趣味を兼ねて、標準パッケージのソースコード読むことは続けていきたいと思います。

読んでいただきありがとうございました。

